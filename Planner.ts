import {aStarSearch} from "./AStarSearch";
import {Graph, SearchResult, Successor} from "./Graph";
import {Conjunction, DNFFormula, Literal, ShrdliteResult, SimpleObject} from "./Types";
import {WorldState} from "./World";

/*
 * Planner
 *
 * The goal of the Planner module is to take the interpetation(s)
 * produced by the Interpreter module and to plan a sequence of
 * actions for the robot to put the world into a state compatible
 * with the user's command, i.e. to achieve what the user wanted.
 */

/**
 * Top-level driver for the Planner.
 * It calls `makePlan` for each given interpretation generated by the Interpreter.
 * You don't have to change this function.
 *
 * @param interpretations: List of possible interpretations.
 * @param world: The current state of the world.
 * @returns: List of planner results, which are the interpretation results augmented with plans.
 *           Each plan is represented by a list of strings.
 *           If there's a planning error, it throws an error with a string description.
 */
export function plan(interpretations: ShrdliteResult[], world: WorldState): ShrdliteResult[] {
    const errors: string[] = [];
    const plans: ShrdliteResult[] = [];
    const planner: Planner = new Planner(world);
    for (const result of interpretations) {
        try {
            result.plan = planner.makePlan(result.interpretation);
        } catch (err) {
            errors.push(err);
            continue;
        }
        if (result.plan.length === 0) {
            result.plan.push("The interpretation is already true!");
        }
        plans.push(result);
    }
    if (plans.length === 0) {
        // merge all errors into one
        throw errors.join(" ; ");
    }
    return plans;
}

class Planner {
    constructor(private world: WorldState) {
    }

    /**
     * Floor of world
     */
    private floor = new SimpleObject("floor", null, null);

    /**
     * The core planner method.
     * Note that you should not change the API (type) of this method, only its body.
     * This method should call the A* search implementation with
     * your implementation of the ShrdliteGraph.
     *
     * @param interpretation: The logical interpretation of the user's desired goal.
     * @returns: A plan, represented by a list of strings.
     *           If there's a planning error, it throws an error with a string description.
     */
    public makePlan(interpretation: DNFFormula): string[] {
        const search = aStarSearch(
            new ShrdliteGraph(),
            ShrdliteNode.fromWorld(this.world),
            (node: ShrdliteNode) => this.checkGoalDNF(node, interpretation),
            (node: ShrdliteNode) => this.getHeuristicDNF(node, interpretation),
            10);
        const result = search.path.map((node) => node.action);
        result.push(`Path with ${search.path.length} moves (${search.visited} visited nodes)`);
        return result;
    }

    private checkGoalDNF(node: ShrdliteNode, interpretation: DNFFormula) {
        return interpretation.conjuncts.some((conjunction) => this.checkGoalConjunction(node, conjunction));
    }

    private checkGoalConjunction(node: ShrdliteNode, conjunction: Conjunction) {
        return conjunction.literals.every((literal) => this.checkGoalLiteral(node, literal));
    }

    private checkGoalLiteral(node: ShrdliteNode, literal: Literal) {
        if (literal.relation === "holding") {
            if (literal.args.length !== 1) {
                throw new Error("Literal needs exactly one argument");
            }
            return literal.args[0] === node.holding;
        }

        if (literal.args.length !== 2) {
            throw new Error("Literal needs exactly two arguments");
        }
        const objectA = this.getObject(literal.args[0]);
        const objectB = this.getObject(literal.args[1]);
        const stackA = this.getStackId(literal.args[0], node.stacks);
        const stackB = this.getStackId(literal.args[1], node.stacks);
        if ((stackA === undefined && objectA !== this.floor)
            || (stackB === undefined && objectB !== this.floor)) {
            return false;
        }

        switch (literal.relation) {
            case "leftof":
                if (stackA === undefined || stackB === undefined) {
                    return false;
                }
                return stackA < stackB;
            case "rightof":
                if (stackA === undefined || stackB === undefined) {
                    return false;
                }
                return stackA > stackB;
            case "inside":
                if (stackA !== stackB) {
                    return false;
                }
                if (objectB.form !== "box") {
                    return false;
                }
                if (stackA === undefined || stackB === undefined) {
                    return false;
                }
                return node.stacks[stackA].indexOf(literal.args[0])
                    === node.stacks[stackB].indexOf(literal.args[1]) + 1;
            case "ontop":
                if (objectB === this.floor && stackA !== undefined
                    && node.stacks[stackA].indexOf(literal.args[0]) === 0) {
                    return true;
                }
                if (stackA === undefined || stackB === undefined) {
                    return false;
                }
                if (stackA !== stackB) {
                    return false;
                }
                if (objectB.form === "box") {
                    return false;
                }
                return node.stacks[stackA].indexOf(literal.args[0])
                    === node.stacks[stackB].indexOf(literal.args[1]) + 1;
            case "under":
                if (objectA === this.floor && node.holding !== literal.args[1]) {
                    return true;
                }
                if (stackA === undefined || stackB === undefined) {
                    return false;
                }
                if (stackA !== stackB) {
                    return false;
                }
                return node.stacks[stackA].indexOf(literal.args[0])
                    < node.stacks[stackB].indexOf(literal.args[1]);
            case "beside":
                return (stackA !== undefined && stackA - 1 === stackB)
                    || (stackB !== undefined && stackA === stackB - 1);
            case "above":
                if (objectB === this.floor && node.holding !== literal.args[0]) {
                    return true;
                }
                if (stackA === undefined || stackB === undefined) {
                    return false;
                }
                if (stackA !== stackB) {
                    return false;
                }
                return node.stacks[stackA].indexOf(literal.args[0]) >
                    node.stacks[stackB].indexOf(literal.args[1]);
            default:
                throw new Error(`Unknown relation: ${literal.relation}`);
        }
    }

    private getHeuristicDNF(node: ShrdliteNode, interpretation: DNFFormula) {
        const values = interpretation.conjuncts.map((conjunction) => this.getHeuristicConjunction(node, conjunction));
        return Math.max.apply(null, values);
    }

    private getHeuristicConjunction(node: ShrdliteNode, conjunction: Conjunction) {
        const values = conjunction.literals.map((literal) => this.getHeuristicLiteral(node, literal));
        return Math.min.apply(null, values);
    }

    private getHeuristicLiteral(node: ShrdliteNode, literal: Literal) {
        if (this.checkGoalLiteral(node, literal)) {
            // Object is in goal state
            return 0;
        }

        let heuristic = 0;

        const stackA = this.getStack(literal.args[0], node.stacks);
        if (stackA === undefined) {
            // Object has been picked up (needs: move, drop)
            heuristic += 1;
        } else {
            // Object is on stack and might be blocked by others (need: pick up, move, drop)
            heuristic += (stackA.length - stackA.indexOf(literal.args[0]) - 1) * 3 + 2;
            // Arm needs to move toward object
            heuristic += Math.abs(node.stacks.indexOf(stackA) - node.arm);
        }

        const objectB = this.getObject(literal.args[1]);
        if (objectB === this.floor) {
            // Object is on the floor, the lowest stack of items will need to be moved (needs: pick up, move, drop)
            heuristic += Math.min.apply(null, node.stacks.map((stack) => stack.length)) * 3;
        } else {
            const stackB = this.getStack(literal.args[1], node.stacks);
            if (stackB === undefined) {
                // Object has been picked up (needs: drop)
                heuristic += 1;
            } else {
                // Object is on stack and might be blocked by others (need: pick up, move, drop)
                heuristic += (stackB.length - stackB.indexOf(literal.args[1]) - 1) * 3;
            }

            // A and B might need to be moved closer together
            const posA = stackA === undefined ? node.arm : node.stacks.indexOf(stackA);
            const posB = stackB === undefined ? node.arm : node.stacks.indexOf(stackB);

            switch (literal.relation) {
                case "leftof":
                    heuristic += Math.max(posA - posB + 1, 0);
                    break;
                case "rightof":
                    heuristic += Math.max(posB - posA + 1, 0);
                    break;
                case "beside":
                    heuristic += Math.min(Math.abs(posA - posB + 1), Math.abs(posB - posA + 1));
                    break;
                case "inside":
                /* falls through */
                case "ontop":
                /* falls through */
                case "under":
                /* falls through */
                case "above":
                /* falls through */
                case "holding":
                    heuristic += Math.abs(posB - posA);
                    break;
                default:
                    throw new Error(`Unknown relation: ${literal.relation}`);
            }
        }
        return heuristic;
    }

    /**
     * Lookup an objects by its name in the world
     * @param {SimpleObject} name: The name of the object to look up
     * @returns {string} The object matching the name
     */
    private getObject(name: string): SimpleObject {
        if (name === "floor") {
            return this.floor;
        }
        return this.world.objects[name];
    }

    private getStack(objectName: string, stacks: string[][]) {
        const filteredStacks = stacks
            .filter((stack) => stack.some((obj) => obj === objectName));

        if (filteredStacks.length === 0) {
            return undefined;
        }
        return filteredStacks[0];
    }

    private getStackId(objectName: string, stacks: string[][]) {
        const stack = this.getStack(objectName, stacks);
        if (stack === undefined) {
            return undefined;
        }
        return stacks.indexOf(stack);
    }
}

/*
 * A* search nodes, to be implemented and cleaned
 */
class ShrdliteNode {
    // String identifier for efficient comparison
    public id: string;

    // Copy of the worlds stacks
    public stacks: string[][];

    constructor(stacks: string[][], public holding: string | null, public  arm: number, private world: WorldState) {
        // Make copy of stacks
        this.stacks = [];
        for (const stack of stacks) {
            this.stacks.push(stack.slice());
        }
    }

    public clone(): ShrdliteNode {
        return new ShrdliteNode(this.stacks, this.holding, this.arm, this.world);
    }

    public static fromWorld(world: WorldState): ShrdliteNode {
        return new ShrdliteNode(world.stacks, world.holding, world.arm, world);
    }

    public toString(): string {
        return this.id;
    }

    public compareTo(other: ShrdliteNode) {
        return this.id.localeCompare(other.id);
    }

    public updateState(action: Action): boolean {
        switch (action) {
            // Move arm left
            case "l":
                if (this.arm === 0) {
                    // Cannot move left from leftmost position
                    return false;
                }
                this.arm--;
                break;
            // Move arm right
            case "r":
                if (this.arm === this.stacks.length - 1) {
                    // Cannot move right from rightmost position
                    return false;
                }
                this.arm++;
                break;
            // Pick up object
            case "p":
                if (this.holding !== null) {
                    // Cannot pick up an item when already holding something
                    return false;
                }
                const pickStack = this.stacks[this.arm];
                if (pickStack.length === 0) {
                    // Cannot pick up from empty stack
                    return false;
                }
                const pickedUp = pickStack.splice(-1, 1);
                this.holding = pickedUp[0];
                break;
            // Drop object
            case "d":
                if (this.holding === null) {
                    // Cannot drop an item without holding something
                    return false;
                }

                // Can drop anything on the floor
                const dropStack = this.stacks[this.arm];
                if (dropStack.length !== 0) {
                    const objectA = this.world.objects[this.holding];
                    const objectB = this.world.objects[dropStack[dropStack.length - 1]];
                    if (objectB.form === "ball") {
                        // Cannot drop anything on a ball
                        return false;
                    }
                    if (objectB.form === "box") {
                        // Inside box
                        if (objectA.size === "large" && objectB.size === "small") {
                            return false;
                        }
                        if (objectA.form === "pyramid" || objectA.form === "plank" || objectA.form === "box") {
                            if (objectB.size === "small" || objectA.size === "large") {
                                return false;
                            }
                        }
                    } else {
                        // On object
                        if (objectA.size === "large" && objectB.size === "small") {
                            return false;
                        }
                        if (objectA.form === "ball") {
                            return false;
                        }
                        if (objectA.form === "box" && objectA.size === "small") {
                            if ((objectB.form === "brick" || objectB.form === "pyramid") && objectB.size === "small") {
                                return false;
                            }
                        }
                        if (objectA.form === "box" && objectA.size === "large") {
                            if (objectB.form === "pyramid") {
                                return false;
                            }
                        }
                    }
                }
                this.stacks[this.arm].push(this.holding);
                this.holding = null;
                break;
        }

        this.id = "";
        for (const stack of this.stacks) {
            this.id += stack.join() + "|";
        }
        this.id += this.arm + "|" + this.holding;
        return true;
    }
}

/*
 * A* search graph, to be implemented and cleaned
 */
class ShrdliteGraph implements Graph<ShrdliteNode> {
    public successors(current: ShrdliteNode): Array<Successor<ShrdliteNode>> {
        const result = [];
        const actions = ["l", "r", "p", "d"];
        for (const action of actions) {
            const node = current.clone();
            if (node.updateState(action)) {
                const successor: Successor<ShrdliteNode> = {child: node, action, cost: 1};
                result.push(successor);
            }
        }
        return result;
    }

    public compareNodes(a: ShrdliteNode, b: ShrdliteNode): number {
        return a.compareTo(b);
    }
}

type Action = "l" | "r" | "p" | "d" | string;
